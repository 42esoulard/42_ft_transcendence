<template>
  <div class="otp-input">
    <h3 class="twofa-h3">Enter your One Time Password</h3>
    <p>Enter the 6 digits code generated by your authentication app</p>
    <transition name="fade--error">
      <p v-if="error" class="error">{{ error }}</p>
    </transition>
    <form class="tac" @submit.prevent="sendTwoFactorCode">
      <input
        v-model="otp"
        v-focus
        type="text"
        maxlength="6"
        size="6"
        name="code"
        autocomplete="off"
        placeholder="000 000"
      />
      <div class="otp_submit">
        <button class="button button--third">Validate code</button>
      </div>
    </form>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from "vue";
import { useRouter } from "vue-router";
import { useStore } from "@/store";
import { useRelationshipApi } from "@/plugins/api.plugin";
import { chatSocket } from "@/App.vue";

export default defineComponent({
  name: "OtpInput",
  props: ["codeSendToUrl", "authApi"],
  setup({ codeSendToUrl, authApi }, { emit }) {
    const router = useRouter();
    const store = useStore();
    const otp = ref("");
    const error = ref("");
    const relationshipApi = useRelationshipApi();

    function isDigit(str: string): boolean {
      return !isNaN(Number(str));
    }

    const checkOtp = () => {
      if (otp.value.length !== 6 || !isDigit(otp.value)) {
        error.value = "Code must be 6 digits long";
      }
    };

    const sendTwoFactorCode = async () => {
      checkOtp(); // some checks over the code
      if (!error.value) {
        if (codeSendToUrl === "turn-on") {
          await authApi
            .turnOnTwoFactorAuthentication(
              { code: otp.value },
              { withCredentials: true }
            )
            .then((res: any) => {
              store.commit("toggleTwoFactor", true);
              store.dispatch("setMessage", res.data.message);
              emit("close");
            })
            .catch((err: any) => {
              error.value = err.response.data.message;
            });
        } else if (codeSendToUrl === "authenticate") {
          await authApi
            .authenticate({ code: otp.value }, { withCredentials: true })
            .then((res: any) => {
              chatSocket.emit("isAlreadyConnected", res.data);
              store.state.user = res.data;
              if (store.state.user.id != 0) {
                relationshipApi
                  .getPendingRelationships(store.state.user.id)
                  .then((res: any) => {
                    if (res.data.length > 0)
                      store.state.toggleFriendship = true;
                  })
                  .catch((err: any) => {
                    if (err && err.response)
                      store.dispatch(
                        "setErrorMessage",
                        err.response.data.message
                      );
                  });
              }
              router.push("/pong");
            })
            .catch((err: any) => (error.value = err.response.data.message));
        }
      }
      if (error.value) {
        setTimeout(() => (error.value = ""), 2000);
      }
    };

    return {
      sendTwoFactorCode,
      otp,
      error,
    };
  },
});
</script>
<style lang="scss">
@import "../../sass/main.scss";
</style>
